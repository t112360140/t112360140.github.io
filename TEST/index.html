<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nRF52840 é™£åˆ—æª¢æ¸¬ (é˜²çˆ†ç‰ˆ)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h2 { color: #333; margin-bottom: 10px; }

        .controls-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1000px;
        }

        button {
            padding: 8px 16px; font-size: 14px; cursor: pointer;
            border: none; border-radius: 4px; transition: background 0.3s; font-weight: bold;
        }
        .btn-connect { background-color: #007bff; color: white; }
        .btn-connect:disabled { background-color: #ccc; cursor: not-allowed; }
        .btn-tare { background-color: #28a745; color: white; }
        .btn-reset { background-color: #ffc107; color: #333; }
        .btn-rotate { background-color: #6c757d; color: white; }

        #status { font-weight: bold; color: #666; margin-left: 10px; }
        .status-connected { color: #28a745 !important; }

        .slider-container { display: flex; align-items: center; gap: 10px; border-left: 1px solid #ddd; padding-left: 15px; }

        #heatmap-wrapper { padding: 10px; background-color: #fff; border-radius: 4px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }

        #heatmap-container {
            display: grid;
            grid-template-columns: repeat(31, 1fr); 
            gap: 1px; background-color: #999; border: 4px solid #333; padding: 2px;
        }
        .grid-horizontal { max-width: 1300px; }
        .grid-vertical { max-width: 380px; }

        /* ========================================= */
        /*  é—œéµä¿®æ”¹ï¼šé˜²æ­¢æ ¼å­è¢«é«’è³‡æ–™æ’å¤§ */
        /* ========================================= */
        .cell {
            aspect-ratio: 1; 
            background-color: #fff; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-size: 10px; 
            color: transparent; 
            user-select: none;
            
            /* 1. è¶…å‡ºç¯„åœéš±è— */
            overflow: hidden;
            /* 2. ç¦æ­¢æ–‡å­—æ›è¡Œ */
            white-space: nowrap;
            /* 3. é‡è¦ï¼šå…è¨± Grid å­å…ƒç´ ç¸®å°åˆ°å…§å®¹å¯¬åº¦ä»¥ä¸‹ */
            min-width: 0;
            min-height: 0;
        }
        
        .cell:hover {
            color: #000; z-index: 10; font-weight: bold; border: 1px solid #333;
            transform: scale(1.5); box-shadow: 0 0 5px rgba(0,0,0,0.3); background-color: white !important; 
            /* hover æ™‚è¦è®“æ–‡å­—å®Œæ•´é¡¯ç¤ºï¼Œæ‰€ä»¥å…è¨± overflow */
            overflow: visible; 
        }
        .cell.error { background-color: #000 !important; color: #ff3333 !important; font-weight: bold; border: 1px solid #555; }

        .legend { margin-top: 15px; display: flex; align-items: center; gap: 10px; font-size: 14px; }
        .gradient-bar {
            width: 300px;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(240,100%,95%), 
                hsl(240,100%,70%), 
                hsl(120,100%,60%), 
                hsl(60,100%,50%), 
                hsl(0,100%,50%)
            );
            border: 1px solid #999;
        }
    </style>
</head>
<body>

    <h2>ğŸ“¡ nRF52840 é™£åˆ—æª¢æ¸¬ - Binary åŒæ­¥ç‰ˆ</h2>
    
    <div class="controls-group">
        <button id="connectBtn" class="btn-connect">ğŸ”µ é€£ç·š Bluetooth</button>
        <button id="disconnectBtn" class="btn-connect" disabled>âŒ æ–·é–‹</button>
        <div id="status">ç‹€æ…‹: æœªé€£ç·š</div>
    </div>

    <div class="controls-group">
        <button id="rotateBtn" class="btn-rotate">ğŸ”„ è¦–åœ–æ—‹è½‰ (0Â°)</button>
        <button id="tareBtn" class="btn-tare">âš–ï¸ è¨­å®šåˆå§‹é›¶é» (Tare)</button>
        <button id="resetTareBtn" class="btn-reset">ğŸ”„ æ¸…é™¤æ ¡æ­£</button>
        <div class="slider-container">
            <label for="gainSlider">Gain: <span id="gainVal">1.0</span>x</label>
            <input type="range" id="gainSlider" min="1" max="10" step="0.5" value="1">
        </div>
    </div>

    <div id="heatmap-wrapper">
        <div id="heatmap-container" class="grid-horizontal"></div>
    </div>

    <div class="legend">
        <span>Low</span><div class="gradient-bar"></div><span>High</span>
    </div>

    <script>
        class BleSerial {
            NUS_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
            NUS_TX_CHAR_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e"; 
            NUS_RX_CHAR_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e"; 

            Device = null; GattServer = null; TxCharacteristic = null; RxCharacteristic = null;
            SerialEvent = { connect: [], disconnect: [], getData: [], sendData: [] };

            constructor(config = {}) {
                this.config = { service: config.service || this.NUS_SERVICE_UUID, tx: config.tx || this.NUS_TX_CHAR_UUID, rx: config.rx || this.NUS_RX_CHAR_UUID };
            }
            async init() {
                try {
                    if (!navigator.bluetooth) throw new Error('Web Bluetooth API not available');
                    this.Device = await navigator.bluetooth.requestDevice({ filters: [{ services: [this.config.service] }], });
                    if (!this.Device) throw new Error('No device selected.');
                    this.Device.addEventListener('gattserverdisconnected', () => this.runEvent('disconnect'));
                    this.GattServer = await this.Device.gatt.connect();
                    const service = await this.GattServer.getPrimaryService(this.config.service);
                    this.TxCharacteristic = await service.getCharacteristic(this.config.tx);
                    this.RxCharacteristic = await service.getCharacteristic(this.config.rx);
                    await this.TxCharacteristic.startNotifications();
                    this.TxCharacteristic.addEventListener('characteristicvaluechanged', (event) => this.runEvent('getData', event.target.value));
                    this.runEvent('connect');
                    return this.Device.name;
                } catch (err) { this.close(); throw new Error(`BLE Error! ${err.message}`); }
            }
            on(event, fun) { if (this.SerialEvent[event]) this.SerialEvent[event].push(fun); }
            runEvent(event, value) { if (this.SerialEvent[event]) this.SerialEvent[event].forEach((fun) => fun(value)); }
            async close() { if (this.GattServer && this.GattServer.connected) this.GattServer.disconnect(); this.Device = null; }
        }

        const DATA_ROWS = 8;
        const DATA_COLS = 31;
        const TOTAL_CELLS = DATA_ROWS * DATA_COLS;
        const PAYLOAD_SIZE = TOTAL_CELLS * 4; 
        const HEADER_SIZE = 4;
        const TOTAL_FRAME_SIZE = HEADER_SIZE + PAYLOAD_SIZE; 
        const HEADER_SEQ = [0xFA, 0xFB, 0xFC, 0xFD];

        const cells = []; 
        let rawMatrixData = new Float32Array(TOTAL_CELLS);
        let baselineData = null;    
        let isCalibrated = false;   
        let signalGain = 1.0;       
        let rotationAngle = 0;

        const ble = new BleSerial();
        let pendingBuffer = new Uint8Array(0); 

        function initGrid() {
            const container = document.getElementById('heatmap-container');
            container.innerHTML = '';
            for (let i = 0; i < TOTAL_CELLS; i++) {
                const div = document.createElement('div');
                div.className = 'cell';
                container.appendChild(div);
                cells.push(div);
            }
        }
        initGrid();

        function getColor(value) {
            // é˜²å‘†ä¿è­·ï¼šå¦‚æœæ•¸å€¼ç•°å¸¸å¤§ï¼Œé™åˆ¶åœ¨ 0~1 ä¹‹é–“è¨ˆç®—é¡è‰²
            let v = value;
            if (isNaN(v) || !isFinite(v)) v = 0;
            v = Math.max(0.1, Math.min(1.0, v));
            let normalized = (v - 0.1) / 0.9; 
            const hue = (1 - normalized) * 240; 
            return `hsl(${hue}, 100%, 50%)`;
        }

        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusDisplay = document.getElementById('status');
        const tareBtn = document.getElementById('tareBtn');
        const resetTareBtn = document.getElementById('resetTareBtn');
        const gainSlider = document.getElementById('gainSlider');
        const gainValDisplay = document.getElementById('gainVal');
        const rotateBtn = document.getElementById('rotateBtn');
        const heatmapContainer = document.getElementById('heatmap-container');

        ble.on('connect', () => {
            statusDisplay.textContent = "ç‹€æ…‹: å·²é€£ç·š";
            statusDisplay.classList.add('status-connected');
            connectBtn.disabled = true; disconnectBtn.disabled = false;
        });

        ble.on('disconnect', () => {
            statusDisplay.textContent = "ç‹€æ…‹: å·²æ–·ç·š";
            statusDisplay.classList.remove('status-connected');
            connectBtn.disabled = false; disconnectBtn.disabled = true;
            pendingBuffer = new Uint8Array(0);
        });

        ble.on('getData', (dataView) => {
            const newChunk = new Uint8Array(dataView.buffer);
            const newBuffer = new Uint8Array(pendingBuffer.length + newChunk.length);
            newBuffer.set(pendingBuffer);
            newBuffer.set(newChunk, pendingBuffer.length);
            pendingBuffer = newBuffer;

            while (pendingBuffer.length >= TOTAL_FRAME_SIZE) {
                let headerIndex = -1;
                for (let i = 0; i < pendingBuffer.length - 3; i++) {
                    if (pendingBuffer[i]   === HEADER_SEQ[0] &&
                        pendingBuffer[i+1] === HEADER_SEQ[1] &&
                        pendingBuffer[i+2] === HEADER_SEQ[2] &&
                        pendingBuffer[i+3] === HEADER_SEQ[3]) {
                        headerIndex = i;
                        break;
                    }
                }

                if (headerIndex === -1) {
                    if (pendingBuffer.length > TOTAL_FRAME_SIZE * 2) {
                        pendingBuffer = pendingBuffer.slice(pendingBuffer.length - HEADER_SIZE);
                    }
                    return; 
                }

                if (headerIndex > 0) {
                    pendingBuffer = pendingBuffer.slice(headerIndex);
                    continue; 
                }

                if (pendingBuffer.length < TOTAL_FRAME_SIZE) return;

                const payloadBytes = pendingBuffer.slice(HEADER_SIZE, TOTAL_FRAME_SIZE);
                const frameDataView = new DataView(payloadBytes.buffer);

                for (let i = 0; i < TOTAL_CELLS; i++) {
                    rawMatrixData[i] = frameDataView.getFloat32(i * 4, true); 
                }

                updateHeatmap();
                pendingBuffer = pendingBuffer.slice(TOTAL_FRAME_SIZE);
            }
        });

        connectBtn.addEventListener('click', async () => {
            try {
                statusDisplay.textContent = "ç‹€æ…‹: æœå°‹ä¸­...";
                await ble.init();
            } catch (err) { statusDisplay.textContent = "ç‹€æ…‹: é€£ç·šå¤±æ•—"; }
        });
        disconnectBtn.addEventListener('click', async () => await ble.close());

        rotateBtn.addEventListener('click', () => {
            rotationAngle = (rotationAngle + 90) % 360;
            rotateBtn.textContent = `ğŸ”„ è¦–åœ–æ—‹è½‰ (${rotationAngle}Â°)`;
            if (rotationAngle === 0 || rotationAngle === 180) {
                heatmapContainer.style.gridTemplateColumns = `repeat(${DATA_COLS}, 1fr)`;
                heatmapContainer.className = 'grid-horizontal';
            } else {
                heatmapContainer.style.gridTemplateColumns = `repeat(${DATA_ROWS}, 1fr)`;
                heatmapContainer.className = 'grid-vertical';
            }
            updateHeatmap();
        });

        tareBtn.addEventListener('click', () => {
            baselineData = new Float32Array(rawMatrixData);
            isCalibrated = true;
            tareBtn.textContent = "âœ… å·²è¨­å®šç‚ºé›¶é»";
            setTimeout(() => tareBtn.textContent = "âš–ï¸ è¨­å®šåˆå§‹é›¶é» (Tare)", 2000);
        });
        resetTareBtn.addEventListener('click', () => { isCalibrated = false; baselineData = null; });
        gainSlider.addEventListener('input', (e) => { signalGain = parseFloat(e.target.value); gainValDisplay.textContent = signalGain.toFixed(1); });

        function getDataIndexByRotation(visualIndex) {
            const R = DATA_ROWS; const C = DATA_COLS;
            let vCols = (rotationAngle === 90 || rotationAngle === 270) ? R : C;
            let vr = Math.floor(visualIndex / vCols); let vc = visualIndex % vCols;
            let dr, dc; 
            if (rotationAngle === 0) { dr = vr; dc = vc; } 
            else if (rotationAngle === 90) { dr = (R - 1) - vc; dc = vr; } 
            else if (rotationAngle === 180) { dr = (R - 1) - vr; dc = (C - 1) - vc; } 
            else if (rotationAngle === 270) { dr = vc; dc = (C - 1) - vr; }
            return dr * C + dc;
        }

        function updateHeatmap() {
            requestAnimationFrame(() => {
                for (let i = 0; i < TOTAL_CELLS; i++) {
                    const cell = cells[i];
                    const dataIndex = getDataIndexByRotation(i);
                    const rawVal = rawMatrixData[dataIndex];

                    // 1. æª¢æŸ¥ NaN æˆ– Infinity
                    if (isNaN(rawVal) || !isFinite(rawVal)) {
                        cell.style.backgroundColor = 'white';
                        cell.textContent = "NaN";
                        continue;
                    }

                    // 2. æ•…éšœä»£ç¢¼æª¢æŸ¥
                    if (Math.abs(rawVal - 0) < 0.001 || Math.abs(rawVal - 16) < 0.001 || Math.abs(rawVal - 32) < 0.001) {
                        cell.className = 'cell error'; cell.textContent = Math.round(rawVal);
                        cell.style.backgroundColor = ''; cell.style.color = ''; continue;
                    } else { cell.className = 'cell'; }

                    let displayVal = rawVal;
                    if (isCalibrated && baselineData) { displayVal = Math.abs(rawVal - baselineData[dataIndex]); }
                    displayVal = displayVal * signalGain;

                    // 3. æ•¸å€¼é‰—åˆ¶ (Clamping) - é˜²æ­¢æ•¸å­—éå¤§æ’é–‹ç‰ˆé¢
                    // å‡è¨­è¶…é 999 å°±ç®—ç•°å¸¸ï¼Œå¼·åˆ¶é¡¯ç¤ºç‚º >999
                    let textToShow = "";
                    if (displayVal > 99) textToShow = ">99";
                    else if (displayVal < -99) textToShow = "<-99";
                    else textToShow = displayVal.toFixed(2);

                    cell.style.backgroundColor = getColor(displayVal);
                    cell.innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";//textToShow;
                    cell.style.color = displayVal > 0.6 ? 'white' : 'transparent';
                }
            });
        }
    </script>
</body>
</html>
