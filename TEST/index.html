<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nRF52840 é™£åˆ—æª¢æ¸¬ (åˆ†è¡Œå°åŒ…ç©©å®šç‰ˆ)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h2 { color: #333; margin-bottom: 10px; }

        .controls-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1000px;
        }

        button {
            padding: 8px 16px; font-size: 14px; cursor: pointer;
            border: none; border-radius: 4px; transition: background 0.3s; font-weight: bold;
        }
        .btn-connect { background-color: #007bff; color: white; }
        .btn-connect:disabled { background-color: #ccc; cursor: not-allowed; }
        .btn-tare { background-color: #28a745; color: white; }
        .btn-reset { background-color: #ffc107; color: #333; }
        .btn-rotate { background-color: #6c757d; color: white; }

        #status { font-weight: bold; color: #666; margin-left: 10px; }
        .status-connected { color: #28a745 !important; }

        .slider-container { display: flex; align-items: center; gap: 10px; border-left: 1px solid #ddd; padding-left: 15px; }

        #heatmap-wrapper { padding: 10px; background-color: #fff; border-radius: 4px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }

        #heatmap-container {
            display: grid;
            grid-template-columns: repeat(31, 1fr); 
            gap: 1px; background-color: #999; border: 4px solid #333; padding: 2px;
        }
        .grid-horizontal { max-width: 1300px; }
        .grid-vertical { max-width: 380px; }

        /* é˜²çˆ†ç‰ˆé¢ CSS */
        .cell {
            aspect-ratio: 1; 
            background-color: #fff; 
            display: flex; align-items: center; justify-content: center;
            font-size: 10px; color: transparent; user-select: none;
            overflow: hidden; white-space: nowrap; min-width: 0; min-height: 0;
        }
        .cell:hover {
            color: #000; z-index: 10; font-weight: bold; border: 1px solid #333;
            transform: scale(1.5); box-shadow: 0 0 5px rgba(0,0,0,0.3); background-color: white !important; 
            overflow: visible; 
        }
        .cell.error { background-color: #000 !important; color: #ff3333 !important; font-weight: bold; border: 1px solid #555; }

        .legend { margin-top: 15px; display: flex; align-items: center; gap: 10px; font-size: 14px; }
        .gradient-bar {
            width: 300px;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(240,100%,95%), 
                hsl(240,100%,70%), 
                hsl(120,100%,60%), 
                hsl(60,100%,50%), 
                hsl(0,100%,50%)
            );
            border: 1px solid #999;
        }
    </style>
</head>
<body>

    <h2>ğŸ“¡ nRF52840 é™£åˆ—æª¢æ¸¬ - åˆ†è¡Œå°åŒ…ç©©å®šç‰ˆ</h2>
    
    <div class="controls-group">
        <button id="connectBtn" class="btn-connect">ğŸ”µ é€£ç·š Bluetooth</button>
        <button id="disconnectBtn" class="btn-connect" disabled>âŒ æ–·é–‹</button>
        <div id="status">ç‹€æ…‹: æœªé€£ç·š</div>
    </div>

    <div class="controls-group">
        <button id="rotateBtn" class="btn-rotate">ğŸ”„ è¦–åœ–æ—‹è½‰ (0Â°)</button>
        <button id="tareBtn" class="btn-tare">âš–ï¸ è¨­å®šåˆå§‹é›¶é» (Tare)</button>
        <button id="resetTareBtn" class="btn-reset">ğŸ”„ æ¸…é™¤æ ¡æ­£</button>
        <div class="slider-container">
            <label for="gainSlider">Gain: <span id="gainVal">1.0</span>x</label>
            <input type="range" id="gainSlider" min="1" max="10" step="0.5" value="1">
        </div>
    </div>

    <div id="heatmap-wrapper">
        <div id="heatmap-container" class="grid-horizontal"></div>
    </div>

    <div class="legend">
        <span>Low</span><div class="gradient-bar"></div><span>High</span>
    </div>

    <script>
        class BleSerial {
            NUS_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
            NUS_TX_CHAR_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e"; 
            NUS_RX_CHAR_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e"; 

            Device = null; GattServer = null; TxCharacteristic = null; RxCharacteristic = null;
            SerialEvent = { connect: [], disconnect: [], getData: [] };

            constructor(config = {}) {
                this.config = { service: config.service || this.NUS_SERVICE_UUID, tx: config.tx || this.NUS_TX_CHAR_UUID, rx: config.rx || this.NUS_RX_CHAR_UUID };
            }
            async init() {
                try {
                    if (!navigator.bluetooth) throw new Error('Web Bluetooth API not available');
                    this.Device = await navigator.bluetooth.requestDevice({ filters: [{ services: [this.config.service] }] });
                    if (!this.Device) throw new Error('No device selected.');
                    this.Device.addEventListener('gattserverdisconnected', () => this.runEvent('disconnect'));
                    this.GattServer = await this.Device.gatt.connect();
                    const service = await this.GattServer.getPrimaryService(this.config.service);
                    this.TxCharacteristic = await service.getCharacteristic(this.config.tx);
                    await this.TxCharacteristic.startNotifications();
                    this.TxCharacteristic.addEventListener('characteristicvaluechanged', (event) => this.runEvent('getData', event.target.value));
                    this.runEvent('connect');
                    return this.Device.name;
                } catch (err) { this.close(); throw new Error(`BLE Error! ${err.message}`); }
            }
            on(event, fun) { if (this.SerialEvent[event]) this.SerialEvent[event].push(fun); }
            runEvent(event, value) { if (this.SerialEvent[event]) this.SerialEvent[event].forEach((fun) => fun(value)); }
            async close() { if (this.GattServer && this.GattServer.connected) this.GattServer.disconnect(); this.Device = null; }
        }

        const DATA_ROWS = 8;
        const DATA_COLS = 31;
        const TOTAL_CELLS = DATA_ROWS * DATA_COLS;
        
        // Protocol Definitions
        const ROW_PACKET_SIZE = 1 + (DATA_COLS * 4); // 1 byte index + 124 bytes data = 125 bytes

        const cells = []; 
        let rawMatrixData = new Float32Array(TOTAL_CELLS);
        let baselineData = null;    
        let isCalibrated = false;   
        let signalGain = 1.0;       
        let rotationAngle = 0;

        const ble = new BleSerial();

        function initGrid() {
            const container = document.getElementById('heatmap-container');
            container.innerHTML = '';
            for (let i = 0; i < TOTAL_CELLS; i++) {
                const div = document.createElement('div');
                div.className = 'cell';
                container.appendChild(div);
                cells.push(div);
            }
        }
        initGrid();

        function getColor(value) {
            let v = value;
            if (isNaN(v) || !isFinite(v)) v = 0;
            v = Math.max(0.1, Math.min(1.0, v));
            let normalized = (v - 0.1) / 0.9; 
            const hue = (1 - normalized) * 240; 
            return `hsl(${hue}, 100%, 50%)`;
        }

        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusDisplay = document.getElementById('status');
        const tareBtn = document.getElementById('tareBtn');
        const resetTareBtn = document.getElementById('resetTareBtn');
        const gainSlider = document.getElementById('gainSlider');
        const gainValDisplay = document.getElementById('gainVal');
        const rotateBtn = document.getElementById('rotateBtn');
        const heatmapContainer = document.getElementById('heatmap-container');

        ble.on('connect', () => {
            statusDisplay.textContent = "ç‹€æ…‹: å·²é€£ç·š (Row Packets)";
            statusDisplay.classList.add('status-connected');
            connectBtn.disabled = true; disconnectBtn.disabled = false;
        });

        ble.on('disconnect', () => {
            statusDisplay.textContent = "ç‹€æ…‹: å·²æ–·ç·š";
            statusDisplay.classList.remove('status-connected');
            connectBtn.disabled = false; disconnectBtn.disabled = true;
        });

        // ==========================================
        //  å…¨æ–°é‚è¼¯ï¼šåˆ†è¡Œå°åŒ…è§£æ
        // ==========================================
        ble.on('getData', (dataView) => {
            // 1. æª¢æŸ¥å°åŒ…é•·åº¦æ˜¯å¦æ­£ç¢º (125 bytes)
            if (dataView.byteLength !== ROW_PACKET_SIZE) {
                // å¦‚æœé•·åº¦ä¸å° (ä¾‹å¦‚ 244 æˆ–å…¶ä»–)ï¼Œä»£è¡¨é€™æ˜¯é›œè¨Šæˆ–ä¸å®Œæ•´çš„åŒ…ï¼Œç›´æ¥ä¸Ÿæ£„
                return;
            }

            // 2. è®€å–è¡Œè™Ÿ (ç¬¬ 0 å€‹ byte)
            const rowIndex = dataView.getUint8(0);

            // å®‰å…¨æª¢æŸ¥ï¼šè¡Œè™Ÿå¿…é ˆåœ¨ 0~7 ä¹‹é–“
            if (rowIndex >= DATA_ROWS) return;

            // 3. è¨ˆç®—è©²è¡Œåœ¨ä¸»é™£åˆ—ä¸­çš„èµ·å§‹ä½ç½®
            const offset = rowIndex * DATA_COLS;

            // 4. è§£æå¾Œé¢çš„ 31 å€‹ float
            // dataView çš„ç¬¬ 1 å€‹ byte é–‹å§‹æ˜¯æ•¸æ“š
            for (let c = 0; c < DATA_COLS; c++) {
                // getFloat32(byteOffset, littleEndian)
                // 1 + c*4 ä»£è¡¨è·³é header (1 byte) å¾Œçš„ç¬¬ c å€‹ float
                const val = dataView.getFloat32(1 + (c * 4), true);
                rawMatrixData[offset + c] = val;
            }

            // 5. æ¯æ”¶åˆ°ä¸€è¡Œå°±å˜—è©¦æ›´æ–°ç•«é¢
            // (requestAnimationFrame æœƒè‡ªå‹•è™•ç†é »ç‡ï¼Œä¸æœƒå› ç‚ºå‘¼å«å¤ªé »ç¹è€Œå¡é “)
            updateHeatmap();
        });

        // ------------------------------------------

        connectBtn.addEventListener('click', async () => {
            try {
                statusDisplay.textContent = "ç‹€æ…‹: æœå°‹ä¸­...";
                await ble.init();
            } catch (err) { statusDisplay.textContent = "ç‹€æ…‹: é€£ç·šå¤±æ•—"; }
        });
        disconnectBtn.addEventListener('click', async () => await ble.close());

        rotateBtn.addEventListener('click', () => {
            rotationAngle = (rotationAngle + 90) % 360;
            rotateBtn.textContent = `ğŸ”„ è¦–åœ–æ—‹è½‰ (${rotationAngle}Â°)`;
            if (rotationAngle === 0 || rotationAngle === 180) {
                heatmapContainer.style.gridTemplateColumns = `repeat(${DATA_COLS}, 1fr)`;
                heatmapContainer.className = 'grid-horizontal';
            } else {
                heatmapContainer.style.gridTemplateColumns = `repeat(${DATA_ROWS}, 1fr)`;
                heatmapContainer.className = 'grid-vertical';
            }
            updateHeatmap();
        });

        tareBtn.addEventListener('click', () => {
            baselineData = new Float32Array(rawMatrixData);
            isCalibrated = true;
            tareBtn.textContent = "âœ… å·²è¨­å®šç‚ºé›¶é»";
            setTimeout(() => tareBtn.textContent = "âš–ï¸ è¨­å®šåˆå§‹é›¶é» (Tare)", 2000);
        });
        resetTareBtn.addEventListener('click', () => { isCalibrated = false; baselineData = null; });
        gainSlider.addEventListener('input', (e) => { signalGain = parseFloat(e.target.value); gainValDisplay.textContent = signalGain.toFixed(1); });

        function getDataIndexByRotation(visualIndex) {
            const R = DATA_ROWS; const C = DATA_COLS;
            let vCols = (rotationAngle === 90 || rotationAngle === 270) ? R : C;
            let vr = Math.floor(visualIndex / vCols); let vc = visualIndex % vCols;
            let dr, dc; 
            if (rotationAngle === 0) { dr = vr; dc = vc; } 
            else if (rotationAngle === 90) { dr = (R - 1) - vc; dc = vr; } 
            else if (rotationAngle === 180) { dr = (R - 1) - vr; dc = (C - 1) - vc; } 
            else if (rotationAngle === 270) { dr = vc; dc = (C - 1) - vr; }
            return dr * C + dc;
        }

        function updateHeatmap() {
            requestAnimationFrame(() => {
                for (let i = 0; i < TOTAL_CELLS; i++) {
                    const cell = cells[i];
                    const dataIndex = getDataIndexByRotation(i);
                    const rawVal = rawMatrixData[dataIndex];

                    if (isNaN(rawVal) || !isFinite(rawVal)) {
                        cell.style.backgroundColor = 'white'; cell.textContent = ""; continue;
                    }

                    if (Math.abs(rawVal - 0) < 0.001 || Math.abs(rawVal - 16) < 0.001 || Math.abs(rawVal - 32) < 0.001) {
                        cell.className = 'cell error'; cell.textContent = Math.round(rawVal);
                        cell.style.backgroundColor = ''; cell.style.color = ''; continue;
                    } else { cell.className = 'cell'; }

                    let displayVal = rawVal;
                    if (isCalibrated && baselineData) { displayVal = Math.abs(rawVal - baselineData[dataIndex]); }
                    displayVal = displayVal * signalGain;

                    // æ•¸å€¼é¡¯ç¤ºä¿è­·
                    let textToShow = "";
                    if (displayVal > 999) textToShow = ">999";
                    else if (displayVal < -999) textToShow = "<-999";
                    else textToShow = displayVal.toFixed(2);

                    cell.style.backgroundColor = getColor(displayVal);
                    cell.textContent = textToShow;
                    cell.style.color = displayVal > 0.6 ? 'white' : 'transparent';
                }
            });
        }
    </script>
</body>
</html>
